/*
 * (C) Copyright 2019-2019, by Semen Chudakov and Contributors.
d *
 * JGraphT : a free Java graph-theory library
 *
 * See the CONTRIBUTORS.md file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0, or the
 * GNU Lesser General Public License v2.1 or later
 * which is available at
 * http://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR LGPL-2.1-or-later
 */
package org.jgrapht.alg.shortestpath;

import org.jgrapht.Graph;
import org.jgrapht.Graphs;
import org.jgrapht.alg.util.Pair;
import org.jgrapht.graph.MaskSubgraph;
import org.jgrapht.graph.builder.GraphTypeBuilder;
import org.jheaps.AddressableHeap;
import org.jheaps.tree.PairingHeap;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Random;
import java.util.Set;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorCompletionService;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.Supplier;

/**
 * Implementation of the <a href="https://en.wikipedia.org/wiki/Contraction_hierarchies">
 * contraction hierarchy route planning precomputation technique.
 *
 * <p>
 * The algorithm for computing the hierarchy is originally described the article: Robert Geisberger,
 * Peter Sanders, Dominik Schultes, and Daniel Delling. 2008. Contraction hierarchies: faster and simpler
 * hierarchical routing in  road networks. In Proceedings of the 7th international conference on Experimental
 * algorithms (WEA'08), Catherine C. McGeoch (Ed.). Springer-Verlag, Berlin, Heidelberg, 319-333.
 *
 * <p>
 * The vertices are first ordered by "importance". A hierarchy is then generated by iteratively contracting
 * the least important vertex. Every vertex gets its vertexId which is its position in the hierarchical ordering.
 * A node v is contracted by removing it from the graph in such a way that shortest paths in the remaining
 * graph are preserved. This property is achieved by replacing paths of the form $(u, v, w)$ by a shortcut edge
 * $(u, w)$. Note that the shortcut $(u, w)$ is only required if $(u, v, w)$ is the only shortest path from $u$
 * to $w$.
 *
 * <p>
 * the graph remains very sparse throughout the contraction pro-
 * cess using rather simple heuristics for ordering the nodes.
 *
 * @param <V> the graph vertex type
 * @param <E> the graph edge type
 * @author Semen Chudakov
 * @since July 2019
 */
public class ContractionHierarchyAlgorithm<V, E> {
    private Graph<V, E> graph;

    private Graph<ContractionVertex<V>, ContractionEdge<E>> contractionGraph;
    private Map<V, ContractionVertex<V>> contractionMapping;
    private Graph<ContractionVertex<V>, ContractionEdge<E>> maskedContractionGraph;

    private Object[] verticesArray;
    private Object[] shortcutsArray;
    private VertexData[] dataArray;

    private AtomicInteger contractionLevelCounter;

    private Supplier<AddressableHeap<Double, ContractionVertex<V>>> shortcutsSearchHeapSupplier;

    private ExecutorService executor;
    private ExecutorCompletionService<Void> completionService;
    private int parallelism;

    private List<ContractionTask> tasks;

    private List<Consumer<ContractionVertex<V>>> computeInitialPrioritiesConsumers;
    private Consumer<ContractionVertex<V>> computeIndependentSetConsumer;
    private Consumer<ContractionVertex<V>> computeShortcutsConsumer;
    private Consumer<ContractionVertex<V>> updateNeighboursConsumer;
    private Consumer<ContractionVertex<V>> markUpwardEdgesConsumer;


    public ContractionHierarchyAlgorithm(Graph<V, E> graph) {
        this(graph, Runtime.getRuntime().availableProcessors());
    }

    public ContractionHierarchyAlgorithm(Graph<V, E> graph, int parallelism) {
        this(graph, parallelism, Random::new, PairingHeap::new);
    }

    public ContractionHierarchyAlgorithm(Graph<V, E> graph, Supplier<Random> randomSupplier) {
        this(graph, Runtime.getRuntime().availableProcessors(), randomSupplier, PairingHeap::new);
    }

    public ContractionHierarchyAlgorithm(Graph<V, E> graph, int parallelism, Supplier<Random> randomSupplier) {
        this(graph, parallelism, randomSupplier, PairingHeap::new);
    }

    public ContractionHierarchyAlgorithm(Graph<V, E> graph, int parallelism, Supplier<Random> randomSupplier,
                                         Supplier<AddressableHeap<Double, ContractionVertex<V>>> shortcutsSearchHeapSupplier) {
        this.graph = graph;
        this.contractionGraph = createContractionGraph();
        this.parallelism = parallelism;
        this.shortcutsSearchHeapSupplier = shortcutsSearchHeapSupplier;

        verticesArray = new Object[graph.vertexSet().size()];
        shortcutsArray = new Object[graph.vertexSet().size()];
        dataArray = new VertexData[graph.vertexSet().size()];

        contractionLevelCounter = new AtomicInteger();

        maskedContractionGraph = new MaskSubgraph<>(contractionGraph,
                v -> dataArray[v.vertexId] != null && dataArray[v.vertexId].isContracted, e -> false);
        contractionMapping = new HashMap<>();
        executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
        completionService = new ExecutorCompletionService<>(executor);

        tasks = new ArrayList<>(parallelism);
        computeInitialPrioritiesConsumers = new ArrayList<>(parallelism);
        for (int i = 0; i < parallelism; ++i) {
            tasks.add(new ContractionTask(i));
            computeInitialPrioritiesConsumers.add(new Consumer<ContractionVertex<V>>() {
                Random random = randomSupplier.get();

                @Override
                public void accept(ContractionVertex<V> vertex) {
                    dataArray[vertex.vertexId] = getPriority(vertex, random.nextInt());
                }
            });
        }


        computeIndependentSetConsumer = vertex -> dataArray[vertex.vertexId].isIndependent = vertexIsIndependent(vertex);
        computeShortcutsConsumer = vertex -> shortcutsArray[vertex.vertexId] = getShortcuts(vertex);
        updateNeighboursConsumer = vertex -> updateNeighboursPriorities(vertex);
        markUpwardEdgesConsumer = vertex -> contractionGraph.outgoingEdgesOf(vertex).forEach(
                e -> e.isUpward = contractionGraph.getEdgeSource(e).contractionLevel <
                        contractionGraph.getEdgeTarget(e).contractionLevel);
    }


    public Pair<Graph<ContractionVertex<V>, ContractionEdge<E>>, Map<V, ContractionVertex<V>>> computeContractionHierarchy() {
        fillContractionGraphAndVerticesArray();
        submitTasks(0, contractionGraph.vertexSet().size(), computeInitialPrioritiesConsumers);

        contractVertices();

        submitTasks(0, contractionGraph.vertexSet().size(), markUpwardEdgesConsumer);
        shutdownExecutor();

        return Pair.of(contractionGraph, contractionMapping);
    }


    private Graph<ContractionVertex<V>, ContractionEdge<E>> createContractionGraph() {
        GraphTypeBuilder<ContractionVertex<V>, ContractionEdge<E>> resultBuilder = GraphTypeBuilder.directed();

        return resultBuilder
                .weighted(true)
                .allowingMultipleEdges(false)
                .allowingSelfLoops(false)
                .buildGraph();
    }

    private void fillContractionGraphAndVerticesArray() {
        int vertexId = 0;
        for (V vertex : graph.vertexSet()) {
            ContractionVertex<V> contractionVertex = new ContractionVertex<>(vertex, vertexId);
            verticesArray[vertexId] = contractionVertex;
            ++vertexId;

            contractionGraph.addVertex(contractionVertex);
            contractionMapping.put(vertex, contractionVertex);
        }

        for (E e : graph.edgeSet()) {
            V source = graph.getEdgeSource(e);
            V target = graph.getEdgeTarget(e);
            if (!source.equals(target)) {

                ContractionVertex<V> contractionSource = contractionMapping.get(source);
                ContractionVertex<V> contractionTarget = contractionMapping.get(target);
                double eWeight = graph.getEdgeWeight(e);

                ContractionEdge<E> oldEdge = contractionGraph.getEdge(contractionSource, contractionTarget);
                if (oldEdge == null) {
                    ContractionEdge<E> forward = new ContractionEdge<>(e);
                    contractionGraph.addEdge(contractionSource, contractionTarget, forward);
                    contractionGraph.setEdgeWeight(forward, eWeight);

                    if (graph.getType().isUndirected()) {
                        ContractionEdge<E> backward = new ContractionEdge<>(e);
                        contractionGraph.addEdge(contractionTarget, contractionSource, backward);
                        contractionGraph.setEdgeWeight(backward, eWeight);
                    }
                } else {
                    double oldWeight = contractionGraph.getEdgeWeight(oldEdge);
                    if (eWeight < oldWeight) {
                        contractionGraph.setEdgeWeight(oldEdge, eWeight);
                        if (graph.getType().isUndirected()) {
                            contractionGraph.setEdgeWeight(
                                    contractionGraph.getEdge(contractionTarget, contractionSource), eWeight);
                        }
                    }
                }
            }
        }
    }


    private void contractVertices() {
        int independentSetStart;
        int independentSetEnd = graph.vertexSet().size();


        int cnt = 0;
        while (independentSetEnd != 0) {
            submitTasks(0, independentSetEnd, computeIndependentSetConsumer);

            independentSetStart = partitionIndependentSet(independentSetEnd);

//            System.out.println(cnt++ + " " + segmentStart + " " + segmentsEnd + " " + (segmentsEnd - segmentStart));

            submitTasks(independentSetStart, independentSetEnd, computeShortcutsConsumer);
            contractIndependentSet(independentSetStart, independentSetEnd);
            submitTasks(independentSetStart, independentSetEnd, updateNeighboursConsumer);
            markContracted(independentSetStart, independentSetEnd);

            independentSetEnd = independentSetStart;
        }
    }


    private boolean vertexIsIndependent(ContractionVertex<V> vertex) {
        double vertexPriority = dataArray[vertex.vertexId].priority;
        for (ContractionVertex<V> firstLevelNeighbour : Graphs.neighborSetOf(maskedContractionGraph, vertex)) {
            double firstLevelPriority = dataArray[firstLevelNeighbour.vertexId].priority;
            if (isGreater(vertexPriority, firstLevelPriority, vertex.vertexId, firstLevelNeighbour.vertexId)) {
                return false;
            }

            for (ContractionVertex<V> secondLevelNeighbour :
                    Graphs.neighborSetOf(maskedContractionGraph, firstLevelNeighbour)) {
                if (!secondLevelNeighbour.equals(vertex)) {
                    double secondLevelPriority = dataArray[secondLevelNeighbour.vertexId].priority;
                    if (isGreater(vertexPriority, secondLevelPriority, vertex.vertexId, secondLevelNeighbour.vertexId)) {
                        return false;
                    }
                }
            }
        }

        return true;
    }

    private boolean isGreater(double priority1, double priority2, int vertexId1, int vertexId2) {
        return priority1 > priority2 || (priority1 == priority2 && tieBreaking(vertexId1, vertexId2));
    }

    private boolean tieBreaking(int vertexId1, int vertexId2) {
        if (dataArray[vertexId1].random != dataArray[vertexId2].random) {
            return dataArray[vertexId1].random > dataArray[vertexId2].random;
        }
        return vertexId1 > vertexId2;
    }


    private int partitionIndependentSet(int notContractedVerticesEnd) {
        int left = 0;
        int right = notContractedVerticesEnd - 1;
        while (left <= right) {
            while (!dataArray[left].isIndependent) {
                ++left;
            }
            while (right >= 0 && dataArray[right].isIndependent) {
                --right;
            }
            if (left <= right) {
                @SuppressWarnings("unchecked")
                ContractionVertex<V> leftVertex = (ContractionVertex<V>) verticesArray[left];
                @SuppressWarnings("unchecked")
                ContractionVertex<V> rightVertex = (ContractionVertex<V>) verticesArray[right];

                swap(dataArray, left, right);
                swap(verticesArray, left, right);
                swap(shortcutsArray, left, right);
                int tmpId = leftVertex.vertexId;
                leftVertex.vertexId = rightVertex.vertexId;
                rightVertex.vertexId = tmpId;
            }

        }
        return left;
    }

    private void swap(Object[] array, int i, int j) {
        Object tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;
    }


    private void contractIndependentSet(int independentSetStart, int independentSetEnd) {
        Arrays.asList(verticesArray).subList(independentSetStart, independentSetEnd).forEach(o -> {
            @SuppressWarnings("unchecked")
            ContractionVertex<V> vertex = (ContractionVertex<V>) o;
            contractVertex(vertex, contractionLevelCounter.getAndIncrement());
        });
    }

    private void contractVertex(ContractionVertex<V> vertex, int contractionLevel) {

        @SuppressWarnings("unchecked")
        List<Pair<ContractionEdge<E>, ContractionEdge<E>>> shortcuts
                = (List<Pair<ContractionEdge<E>, ContractionEdge<E>>>) shortcutsArray[vertex.vertexId];
        shortcutsArray[vertex.vertexId] = null;
        VertexData data = dataArray[vertex.vertexId];

        // add shortcuts
        for (Pair<ContractionEdge<E>, ContractionEdge<E>> shortcut : shortcuts) {
            ContractionVertex<V> shortcutSource = maskedContractionGraph.getEdgeSource(shortcut.getFirst());
            ContractionVertex<V> shortcutTarget = maskedContractionGraph.getEdgeTarget(shortcut.getSecond());
            ContractionEdge<E> shortcutEdge = new ContractionEdge<>(shortcut);

            boolean added = contractionGraph.addEdge(shortcutSource, shortcutTarget, shortcutEdge);

            double weight = maskedContractionGraph.getEdgeWeight(shortcut.getFirst())
                    + maskedContractionGraph.getEdgeWeight(shortcut.getSecond());

            if (added) {
                contractionGraph.setEdgeWeight(shortcutEdge, weight);
            } else {
                contractionGraph.setEdgeWeight(contractionGraph.getEdge(shortcutSource, shortcutTarget), weight);
            }
        }

        // update vertex data
        vertex.contractionLevel = contractionLevel;
    }


    private void updateNeighboursPriorities(ContractionVertex<V> vertex) {
        Set<ContractionVertex<V>> neighbours = Graphs.neighborSetOf(maskedContractionGraph, vertex);
        VertexData vertexData = dataArray[vertex.vertexId];
        for (ContractionVertex<V> neighbour : neighbours) {
            VertexData neighbourData = dataArray[neighbour.vertexId];
            neighbourData.depth = Math.max(neighbourData.depth, vertexData.depth + 1);
            updatePriority(neighbour, neighbourData);
        }
    }


    private VertexData getPriority(ContractionVertex<V> vertex, int random) {
        VertexData result = new VertexData(random);
        updatePriority(vertex, result);
        return result;
    }

    private void updatePriority(ContractionVertex<V> vertex, VertexData data) {
        VertexStatistics statistics = getStatistics(vertex);
        if (statistics.removedContractionEdges * statistics.removeOriginalEdges == 0) {
            data.priority = data.depth;
        } else {
            data.priority = 4.0 * statistics.addedContractionEdges / statistics.removedContractionEdges +
                    2.0 * statistics.addedOriginalEdges / statistics.removeOriginalEdges +
                    1.0 * data.depth;
        }

    }

    private VertexStatistics getStatistics(ContractionVertex<V> vertex) {
        ToShortcutsStatisticsConsumer consumer = new ToShortcutsStatisticsConsumer();
        iterateShortcuts(vertex, consumer);
        addRemovedEdgesStatistics(vertex, consumer.statistics);
        return consumer.statistics;
    }

    private void addRemovedEdgesStatistics(ContractionVertex<V> vertex, VertexStatistics statistics) {
        maskedContractionGraph.edgesOf(vertex).forEach(e -> {
            ++statistics.removedContractionEdges;
            statistics.removeOriginalEdges += e.originalEdges;
        });
    }


    private List<Pair<ContractionEdge<E>, ContractionEdge<E>>> getShortcuts(ContractionVertex<V> vertex) {
        ToListConsumer consumer = new ToListConsumer();
        iterateShortcuts(vertex, consumer);
        return consumer.shortcuts;
    }


    private void iterateShortcuts(ContractionVertex<V> vertex,
                                  BiConsumer<ContractionEdge<E>, ContractionEdge<E>> shortcutConsumer) {
        Set<ContractionVertex<V>> successors = new HashSet<>();
        double maxOutgoingEdgeWeight = Double.MIN_VALUE;

        for (ContractionEdge<E> outEdge : maskedContractionGraph.outgoingEdgesOf(vertex)) {
            ContractionVertex<V> successor = maskedContractionGraph.getEdgeTarget(outEdge);

            if (dataArray[successor.vertexId] != null) {
                if (dataArray[successor.vertexId].isIndependent) {
                    continue;
                }
            }

            successors.add(successor);
            maxOutgoingEdgeWeight = Math.max(maxOutgoingEdgeWeight, contractionGraph.getEdgeWeight(outEdge));
        }


        for (ContractionEdge<E> inEdge : maskedContractionGraph.incomingEdgesOf(vertex)) {
            ContractionVertex<V> predecessor = contractionGraph.getEdgeSource(inEdge);
            if (dataArray[predecessor.vertexId] != null &&
                    dataArray[predecessor.vertexId].isIndependent) {
                continue;
            }

            boolean containedPredecessor = successors.remove(predecessor); // might contain the predecessor vertex itself

            Map<ContractionVertex<V>, AddressableHeap.Handle<Double, ContractionVertex<V>>> distances =
                    iterateToSuccessors(maskedContractionGraph,
                            predecessor,
                            successors,
                            vertex,
                            contractionGraph.getEdgeWeight(inEdge) + maxOutgoingEdgeWeight);

            for (ContractionVertex<V> successor : successors) {
                ContractionEdge<E> outEdge = contractionGraph.getEdge(vertex, successor);
                double pathWeight = contractionGraph.getEdgeWeight(inEdge) + contractionGraph.getEdgeWeight(outEdge);

                if (!distances.containsKey(successor) || distances.get(successor).getKey() > pathWeight) {
                    shortcutConsumer.accept(inEdge, outEdge);
                    if (graph.getType().isUndirected()) {
                        shortcutConsumer.accept(contractionGraph.getEdge(successor, vertex),
                                contractionGraph.getEdge(vertex, predecessor));
                    }
                }
            }

            if (containedPredecessor && graph.getType().isDirected()) {
                successors.add(predecessor);
            }
        }
    }


    private void markContracted(int independentSetStart, int independentSetEnd) {
        for (int i = independentSetStart; i < independentSetEnd; ++i) {
            dataArray[((ContractionVertex<V>) verticesArray[i]).vertexId].isContracted = true;
        }
    }


    private Map<ContractionVertex<V>, AddressableHeap.Handle<Double, ContractionVertex<V>>>
    iterateToSuccessors(Graph<ContractionVertex<V>, ContractionEdge<E>> graph,
                        ContractionVertex<V> source,
                        Set<ContractionVertex<V>> targets,
                        ContractionVertex<V> forbiddenVertex,
                        double radius) {
        AddressableHeap<Double, ContractionVertex<V>> heap = shortcutsSearchHeapSupplier.get();
        Map<ContractionVertex<V>, AddressableHeap.Handle<Double, ContractionVertex<V>>> distanceMap = new HashMap<>();
        updateDistance(source, 0.0, heap, distanceMap);

        int numOfSuccessors = targets.size();
        int passedSuccessors = 0;

        while (!heap.isEmpty()) {
            AddressableHeap.Handle<Double, ContractionVertex<V>> min = heap.deleteMin();
            ContractionVertex<V> vertex = min.getValue();
            double distance = min.getKey();

            if (distance > radius) {
                break;
            }

            if (targets.contains(vertex)) {
                ++passedSuccessors;
                if (passedSuccessors == numOfSuccessors) {
                    break;
                }
            }

            relaxNode(graph, heap, distanceMap, vertex, distance, forbiddenVertex);
        }
        return distanceMap;
    }

    private void relaxNode(Graph<ContractionVertex<V>, ContractionEdge<E>> graph,
                           AddressableHeap<Double, ContractionVertex<V>> heap,
                           Map<ContractionVertex<V>, AddressableHeap.Handle<Double, ContractionVertex<V>>> map,
                           ContractionVertex<V> vertex,
                           double vertexDistance,
                           ContractionVertex<V> forbiddenVertex) {

        for (ContractionEdge<E> edge : graph.outgoingEdgesOf(vertex)) {
            ContractionVertex<V> successor = graph.getEdgeTarget(edge);

            if (successor.equals(forbiddenVertex) ||
                    (dataArray[successor.vertexId] != null && dataArray[successor.vertexId].isIndependent)) {
                // skip independent vertices because they will be contracted
                continue;
            }

            double updatedDistance = vertexDistance + graph.getEdgeWeight(edge);

            updateDistance(successor, updatedDistance, heap, map);
        }
    }

    private void updateDistance(ContractionVertex<V> v, double distance,
                                AddressableHeap<Double, ContractionVertex<V>> heap,
                                Map<ContractionVertex<V>, AddressableHeap.Handle<Double, ContractionVertex<V>>> map) {
        AddressableHeap.Handle<Double, ContractionVertex<V>> node = map.get(v);
        if (node == null) {
            node = heap.insert(distance, v);
            map.put(v, node);
        } else if (distance < node.getKey()) {
            node.decreaseKey(distance);
        }
    }





    private void submitTasks(int segmentStart, int segmentEnd, Consumer<ContractionVertex<V>> consumer) {
        for (ContractionTask task : tasks) {
            task.consumer = consumer;
            task.segmentStart = segmentStart;
            task.segmentsEnd = segmentEnd;
            completionService.submit(task, null);
        }
        takeTasks(tasks.size());
    }

    private void submitTasks(int segmentStart, int segmentEnd, List<Consumer<ContractionVertex<V>>> consumers) {
        for (int i = 0; i < tasks.size(); ++i) {
            ContractionTask task = tasks.get(i);
            task.consumer = consumers.get(i);
            task.segmentStart = segmentStart;
            task.segmentsEnd = segmentEnd;
            completionService.submit(task, null);
        }
        takeTasks(tasks.size());
    }

    private void takeTasks(int numOfTasks) {
        for (int i = 0; i < numOfTasks; ++i) {
            try {
                completionService.take().get();
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }
        }
    }

    private void shutdownExecutor() {
        executor.shutdown();
        try {
            executor.awaitTermination(Long.MAX_VALUE, TimeUnit.MILLISECONDS);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }


    public static class ContractionVertex<V1> {
        int vertexId;
        V1 vertex;
        int contractionLevel;

        ContractionVertex(V1 vertex, int vertexId) {
            this.vertexId = vertexId;
            this.vertex = vertex;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            ContractionVertex<?> that = (ContractionVertex<?>) o;
            return Objects.equals(vertex, that.vertex);
        }

        @Override
        public int hashCode() {
            return Objects.hash(vertex);
        }

        @Override
        public String toString() {
            return "ContractionVertex{" +
                    "vertexId=" + vertexId +
                    ", vertex=" + vertex +
                    ", contractionLevel=" + contractionLevel +
                    '}';
        }
    }

    public static class ContractionEdge<E1> {
        E1 edge;
        Pair<ContractionEdge<E1>, ContractionEdge<E1>> skippedEdges;
        boolean isUpward;
        int originalEdges;

        ContractionEdge(E1 edge) {
            this.edge = edge;
            this.originalEdges = 1;
        }

        ContractionEdge(Pair<ContractionEdge<E1>, ContractionEdge<E1>> skippedEdges) {
            this.skippedEdges = skippedEdges;
            this.originalEdges = skippedEdges.getFirst().originalEdges + skippedEdges.getSecond().originalEdges;
        }

        @Override
        public String toString() {
            return "ContractionEdge{" +
                    "edge=" + edge +
                    ", skippedEdges=" + skippedEdges +
                    ", isUpward=" + isUpward +
                    ", originalEdges=" + originalEdges +
                    '}';
        }
    }


    private class ToListConsumer implements BiConsumer<ContractionEdge<E>, ContractionEdge<E>> {
        List<Pair<ContractionEdge<E>, ContractionEdge<E>>> shortcuts;

        ToListConsumer() {
            shortcuts = new ArrayList<>();
        }

        @Override
        public void accept(ContractionEdge<E> e1, ContractionEdge<E> e2) {
            shortcuts.add(Pair.of(e1, e2));
        }
    }

    private class ToShortcutsStatisticsConsumer implements BiConsumer<ContractionEdge<E>, ContractionEdge<E>> {
        VertexStatistics statistics;

        ToShortcutsStatisticsConsumer() {
            this.statistics = new VertexStatistics();
        }

        @Override
        public void accept(ContractionEdge<E> e1, ContractionEdge<E> e2) {
            ++statistics.addedContractionEdges;
            statistics.addedOriginalEdges += e1.originalEdges + e2.originalEdges;
        }
    }


    private class ContractionTask implements Runnable {
        int workerId;
        int segmentStart;
        int segmentsEnd;
        Consumer<ContractionVertex<V>> consumer;

        public ContractionTask(int workerId) {
            this.workerId = workerId;
        }

        @Override
        public void run() {
            int start = workerSegmentStart(segmentStart, segmentsEnd, workerId);
            int end = workerSegmentEnd(segmentStart, segmentsEnd, workerId);
            for (int i = start; i < end; ++i) {
                try {
                    consumer.accept((ContractionVertex<V>) verticesArray[i]);
                } catch (NullPointerException e) {
                    System.out.println(verticesArray);
                    System.out.println(verticesArray[i]);
                    throw e;
                }
            }
        }

        private int workerSegmentStart(int start, int end, int workerId) {
            return start + ((end - start) * workerId) / parallelism;
        }

        private int workerSegmentEnd(int start, int end, int workerId) {
            return start + ((end - start) * (workerId + 1)) / parallelism;
        }
    }


    private static class VertexData {
        int depth;
        double priority;
        boolean isContracted;
        boolean isIndependent;
        int random;

        VertexData(int random) {
            this.random = random;
        }
    }

    private static class VertexStatistics {
        int addedContractionEdges;
        int removedContractionEdges;
        int addedOriginalEdges;
        int removeOriginalEdges;
    }
}
